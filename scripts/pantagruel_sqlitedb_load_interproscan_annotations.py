#!/usr/bin/python
# -*- coding: utf-8 -*-
import glob, os, sys
import sqlite3

# input is expected from a TSV table file generated by interproscan program
# when ran with options '--iprlookup --go_terms --pathways'
# the table should contain the following fields:
	#~ nr_protein_id varchar(20) not null,
	#~ sequence_md5_digest text not null,
	#~ sequence_length smallint not null,
	#~ analysis_method text not null,
	#~ signature_accession text not null,
	#~ signature_description text not null,
	#~ start_location smallint not null,
	#~ stop_location smallint not null,
	#~ score_or_evalue real not null,
	#~ status char(1) not null,
	#~ date char(10) not null,
	#~ interpro_id varchar(10),
	#~ interpro_description text,
	#~ go_terms text,
	#~ pathways text
# these fileds will however be despatched between several tables in the SQL database, to avoid redundancy:
# 'protein_infos', 'functional_annotations', 'interpro_terms', 'interpro2GO', 'interpro2pathways'.



nfsqldb = sys.argv[1]
dirinterproscan = sys.argv[2]
interproscanversion = sys.argv[3]

dbcon = sqlite3.connect(nfsqldb)
dbcon.text_factory = str
dbcur = dbcon.cursor()

filesuffix = "_protein.tsv"
lnfinterproscan = glob.glob(os.path.join(dirinterproscan, '*', '*'+filesuffix))
tipv = (interproscanversion,)

# keep track of recorded proteins that may be redundant across the several annotation files (each of which corresponds ot a single proteome)
srecprot = set([])
srecip = set([])
# first record what may already have been loaded in the database
dbcur.execute("SLECT DISTINCT nr_protein_id FROM functional_annotations WHERE interproscan_version=%s ;", tipv)
srecprot |= set([t[0] for t in dbcur.fetchall()])
dbcur.execute("SLECT DISTINCT interpro_id FROM interpro_terms ;")
srecip |= set([t[0] for t in dbcur.fetchall()])

for nfinterproscan in lnfinterproscan:
	ass = os.path.basename(nfinterproscan).replace(filesuffix, '')
	print "parse functional annotations of proteome from assembly %s"%ass
	with open(nfinterproscan, 'r') as finterproscan:
		# first extract lines, filtering those already represented in the protein set
		ltproti = []
		ltannot = []
		ltipacc = []
		ltip2go = []
		ltip2pw = []
		currprotid = None
		for line in finterproscan:
			tsp = tuple(line.rstrip('\n').split('\t'))
			protid = tsp[0]
			if protid != currprotid:
				# assume that all entries for a protein are grouped in one proteome annotation file
				if currprotid: srecprot.add(currprotid)
				currprotid = protid
				# distribute protein description and Interproscan hits into different tables:
				# 'protein_infos'
				ltproti.append(tsp[:3])
			if protid not in srecprot:
				# 'functional_annotations'
				ipscanfileds = tsp[:1]+tsp[3:11]
				if len(tsp)<12:
					ltannot.append(ipscanfileds+(None,)+tipv)
				else:
					ipid = tsp[11]
					ltannot.append(ipscanfileds+(ipid,)+tipv)
					if ipid not in srecip:
						srecip.add(ipid)
						# distribute Interpro accession description and DB cross-references into different tables:
						# 'interpro_terms'
						ltipacc.append(tsp[11:13])
						# 'interpro2GO'
						ip2go = tsp[13]
						if ip2go: ltip2go += [(ipid, goid) for goid in ip2go.split('|')]
						# 'interpro2pathway'
						ip2pw = tsp[14]
						if ip2pw: ltip2pw += [(ipid,)+tuple(pwdbid.split(': ')) for pwdbid in ip2pw.split('|')]
		# completes the record with last protein
		srecprot.add(currprotid)
		# insert data into tables
		dbcur.executemany("""INSERT INTO protein_infos 
							 (nr_protein_id, sequence_md5_digest, sequence_length) VALUES (?,?,?);""", ltproti)
		dbcur.executemany("""INSERT INTO functional_annotations 
							 (nr_protein_id, 
							 analysis_method, signature_accession, signature_description, 
							 start_location, stop_location, score_or_evalue, 
							 analysis_status, analysis_date, 
							 interpro_id, interproscan_version) VALUES (?,?,?,?,?,?,?,?,?,?,?);""", ltannot)
		dbcur.executemany("""INSERT INTO interpro_terms
							 (interpro_id, interpro_description) VALUES (?,?);""", ltipacc)
		dbcur.executemany("""INSERT INTO interpro2GO
							 (interpro_id, go_id) VALUES (?,?);""", ltip2go)
		dbcur.executemany("""INSERT INTO interpro2pathways
							 (interpro_id, pathway_db, pathway_id) VALUES (?,?,?);""", ltip2pw)
		print "inserted values into tables: protein_infos, % 5d; functional_annotations, % 5d; interpro_terms, % 5d; interpro2GO, % 5d; interpro2pathway, % 5d."%(len(ltproti), len(ltannot), len(ltipacc), len(ltip2go), len(ltip2pw))

print "%s database total changes:"%nfsqldb, dbcon.total_changes

indexscript = """
                 CREATE INDEX IF NOT EXISTS funcannot_nrproteinid_idx ON functional_annotations (nr_protein_id);
                 CREATE INDEX IF NOT EXISTS funcannot_nrproteinid_idx ON functional_annotations (analysis_method);
                 CREATE INDEX IF NOT EXISTS funcannot_nrproteinid_idx ON functional_annotations (signature_accession);
                 CREATE INDEX IF NOT EXISTS funcannot_method_signacc_idx ON functional_annotations (analysis_method, signature_accession);
                 CREATE UNIQUE INDEX IF NOT EXISTS funcannot_nrproteinid_method_signacc_location_ipversion_uniq ON functional_annotations
                  (nr_protein_id, analysis_method, signature_accession, start_location, stop_location, interproscan_version);
                 CREATE INDEX IF NOT EXISTS funcannot_score_idx ON functional_annotations (score_or_evalue);
                 CREATE INDEX IF NOT EXISTS funcannot_interproid_idx ON functional_annotations (interpro_id);
                 CREATE UNIQUE INDEX IF NOT EXISTS ipterms_interproid_uniq ON interpro_terms (interpro_id);
                 CREATE UNIQUE INDEX IF NOT EXISTS ip2go_interproid_goid_uniq ON interpro2GO (interpro_id, go_id);
                 CREATE INDEX IF NOT EXISTS ip2go_interproid_idx ON interpro2GO (interpro_id);
                 CREATE INDEX IF NOT EXISTS ip2go_goid_idx ON interpro2GO (go_id);
                 CREATE UNIQUE INDEX IF NOT EXISTS ip2pw_interproid_pwdb_pwid_uniq ON interpro2pathways (interpro_id, pathway_db, pathway_id);
                 CREATE INDEX IF NOT EXISTS ip2pw_pwdb_pwid_idx ON interpro2pathways (pathway_db, pathway_id);
                 CREATE INDEX IF NOT EXISTS ip2pw_interproid_idx ON interpro2pathways (interpro_id);
                 CREATE INDEX IF NOT EXISTS ip2pw_pwdb_idx ON interpro2pathways (pathway_db);
                 CREATE INDEX IF NOT EXISTS ip2pw_pwid_idx ON interpro2pathways (pathway_id);"""
                 
dbcur.executescript(indexscript)

print "created indexes as follows: %s"%(indexscript.replace('                 ', ''))

dbcon.commit()
dbcon.close()



